#include <Arduino.h>
#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <Keypad.h>

#define SCREEN_WIDTH 128    // Ancho de la pantalla OLED en píxeles
#define SCREEN_HEIGHT 64    // Alto de la pantalla OLED en píxeles
#define OLED_RESET -1       // Pin de reset (o -1 si se comparte el pin de reset del Arduino)
#define SCREEN_ADDRESS 0x3C ///< Ver la hoja de datos para la dirección; 0x3D para 128x64, 0x3C para 128x32

#define pinPWM 32

const int leds = 8;
int pinesLeds[leds] = {15, 2, 4, 16, 17, 5, 18, 19};
int primerGrupo[4] = {pinesLeds[0], pinesLeds[1], pinesLeds[2], pinesLeds[3]};

// Segundo grupo de LEDs (pines del 4 al 7)
int segundoGrupo[4] = {pinesLeds[4], pinesLeds[5], pinesLeds[6], pinesLeds[7]};

unsigned long tactual;
unsigned long tinicio;
unsigned long periodo = 200;
unsigned long tultimocambio = 0;
bool incremento = true;

String cadena = "";
int valor = 0;
int currentLed = 0; // Índice del LED actualmente encendido
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

#define BTN 35
#define SW 34

hw_timer_t *Timer0_Cfg = NULL;

// Definir pines para el teclado alfanumérico
const byte ROWS = 4;
const byte COLS = 4;
char keys[ROWS][COLS] = {
    {'1', '2', '3', 'A'},
    {'4', '5', '6', 'B'},
    {'7', '8', '9', 'C'},
    {'*', '0', '#', 'D'}};
byte rowPins[ROWS] = {33, 25, 26, 27}; // Filas
byte colPins[COLS] = {14, 12, 13, 23}; // Columnas

Keypad keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

void secuencia1(void);
void secuencia2(void);
void secuencia3(void);
void secuencia4(void);
void secuencia5(void);

void conf_sw_btn(void);
void conf_timer(void);

void IRAM_ATTR isr_start_stop()
{
  // Código de la interrupción de inicio/parada
}
void IRAM_ATTR isr_secuencia()
{
  // Código de la interrupción de borrado
}
void IRAM_ATTR Timer0_ISR()
{
  // Alternate the logic value of the MOSFET pin
  digitalWrite(pinPWM, !digitalRead(pinPWM));
}

void setup()
{
  pinMode(pinPWM, OUTPUT);
  conf_timer();

  display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS);
  display.clearDisplay();

  display.setTextSize(0.5);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(5, 10);
  display.println(F("CICLO UTIL:     %"));
  display.setCursor(5, 25);
  display.println(F("ESTADO: "));
  display.setCursor(5, 40);
  display.println(F("SECUENCIA:"));
  display.setCursor(5, 55);
  display.println(F("INTR CICLO UTIL: "));
  display.drawLine(0, 50, 127, 50, SSD1306_WHITE);
  display.display();

  conf_sw_btn();
  conf_timer();

  // Inicialización de pines LED
  for (int i = 0; i < leds; i++)
  {
    pinMode(pinesLeds[i], OUTPUT);
  }
}
void loop()
{
  secuencia5();
  char tecla = keypad.getKey();

  if (tecla != NO_KEY)
  {
    if (tecla == '#')
    {
      valor = constrain(cadena.toInt(), 0, 100); // Limita el valor entre 0 y 100
      display.setCursor(80, 10);
      display.print(valor); // Imprime el valor ingresado en pantalla
      cadena = "";          // Reinicia la cadena para la próxima entrada
    }
    else if (isdigit(tecla) && cadena.length() < 3) // Solo agrega dígitos si la cadena tiene menos de 3 caracteres
    {
      cadena += tecla; // Agrega la tecla a la cadena
      display.setCursor(100, 55);
      display.print(cadena); // Imprime la cadena en pantalla
    }
  }
  display.display(); // Actualiza la pantalla después de cada iteración
}

void conf_sw_btn(void)
{
  pinMode(SW, INPUT);
  pinMode(BTN, INPUT);
  attachInterrupt(digitalPinToInterrupt(SW), isr_start_stop, FALLING);
  attachInterrupt(digitalPinToInterrupt(BTN), isr_secuencia, FALLING);
}

void conf_timer(void)
{
  Timer0_Cfg = timerBegin(0, 80, true);
  timerAttachInterrupt(Timer0_Cfg, &Timer0_ISR, true);
  timerAlarmWrite(Timer0_Cfg, 40, true);
  timerAlarmEnable(Timer0_Cfg);
}

void secuencia1(void)
{
  tactual = millis();
  if (tactual - tinicio >= periodo)
  {
    tinicio = tactual;

    // Apaga el LED en la posición anterior a currentLed
    int anteriorLed = (currentLed == 0) ? leds - 1 : currentLed - 1;
    digitalWrite(pinesLeds[anteriorLed], LOW);

    // Enciende el LED en la posición currentLed
    digitalWrite(pinesLeds[currentLed], HIGH);

    // Actualiza el valor de currentLed para el siguiente ciclo
    currentLed = (currentLed + 1) % leds;
  }
}
void secuencia2(void)
{
  unsigned long tactual = millis();
  if (tactual - tinicio >= periodo)
  {
    tinicio = tactual;

    // Intercambia el estado de los LEDs (encendidos por apagados y viceversa)
    for (int i = 0; i < leds; i++)
    {
      digitalWrite(pinesLeds[i], !digitalRead(pinesLeds[i])); // Invierte el estado del LED
    }
  }
}
void secuencia3(void)
{
  unsigned long tactual = millis();
  if (tactual - tinicio >= 300)
  {
    tinicio = tactual;

    digitalWrite(pinesLeds[currentLed], !digitalRead(pinesLeds[currentLed]));

    if (incremento)
    {
      currentLed++;
      if (currentLed == leds)
      {
        currentLed = leds - 2;
        incremento = false;
      }
    }
    else
    {
      currentLed--;
      if (currentLed < 0)
      {
        currentLed = 1;
        incremento = true;
      }
    }
  }
}
void secuencia4(void)
{
  unsigned long tactual = millis();

  if (tactual - tinicio >= periodo)
  {
    digitalWrite(pinesLeds[currentLed], !digitalRead(pinesLeds[currentLed]));

    tinicio = tactual;

    currentLed = (currentLed + 1) % leds;
  }
}
void secuencia5(void)
{
  tactual = millis();
  // Verificar si ha pasado el tiempo suficiente para cambiar de estado
  if (tactual - tinicio >= periodo)
  {
    tinicio = tactual;
    static bool primerGrupoEncendido = false; // Estado inicial

    // Cambiar el estado del primer grupo de LEDs (pines del 0 al 3)
    for (int i = 0; i < 4; i++)
    {
      digitalWrite(primerGrupo[i], primerGrupoEncendido ? LOW : HIGH);
    }

    // Cambiar el estado del segundo grupo de LEDs (pines del 4 al 7)
    for (int i = 0; i < 4; i++)
    {
      digitalWrite(segundoGrupo[i], primerGrupoEncendido ? HIGH : LOW);
    }

    primerGrupoEncendido = !primerGrupoEncendido; // Invertir el estado para el próximo ciclo
  }
}
