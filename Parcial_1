#include <Arduino.h>
#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_system.h"
#include "esp_log.h"
#include "driver/gpio.h"
#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <Keypad.h>

#define SCREEN_WIDTH 128    // Ancho de la pantalla OLED en píxeles
#define SCREEN_HEIGHT 64    // Alto de la pantalla OLED en píxeles
#define OLED_RESET -1       // Pin de reset (o -1 si se comparte el pin de reset del Arduino)
#define SCREEN_ADDRESS 0x3C ///< Ver la hoja de datos para la dirección; 0x3D para 128x64, 0x3C para 128x32

const int leds = 8;
int pinesLeds[leds] = {15, 2, 4, 16, 17, 5, 18, 19};

unsigned long tactual;
unsigned long tinicio;
unsigned long periodo = 1000;

int currentLed = 0; // Índice del LED actualmente encendido

Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

#define BTN 35
#define SW 34

hw_timer_t *Timer0_Cfg = NULL;

// Definir pines para el teclado alfanumérico
const byte ROWS = 4;
const byte COLS = 4;
char keys[ROWS][COLS] = {
    {'1', '2', '3', 'A'},
    {'4', '5', '6', 'B'},
    {'7', '8', '9', 'C'},
    {'*', '0', '#', 'D'}};
byte rowPins[ROWS] = {33, 25, 26, 27}; // Filas
byte colPins[COLS] = {14, 12, 13, 23}; // Columnas

Keypad keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

void secuencia1(void);
void conf_sw_btn(void);
void conf_timer(void);

void IRAM_ATTR isr_start_stop()
{
  // Código de la interrupción de inicio/parada
}

void IRAM_ATTR isr_clear()
{
  // Código de la interrupción de borrado
}

void IRAM_ATTR Timer0_ISR()
{
  // Código de la interrupción del timer
}

void setup()
{
  for (int i = 0; i < leds; i++) {
    pinMode(pinesLeds[i], OUTPUT);
  }

  display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS);
  display.clearDisplay();

  display.setTextSize(0.5);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(5, 10);
  display.println(F("CICLO UTIL:  %"));
  display.setCursor(5, 25);
  display.println(F("ESTADO: "));
  display.setCursor(5, 40);
  display.println(F("SECUENCIA:"));
  display.setCursor(5, 55);
  display.println(F("INTRO CICLO UTIL:"));
  display.drawLine(0, 50, 127, 50, SSD1306_WHITE);
  display.display();

  conf_sw_btn();
  conf_timer();
}

void loop()
{
  secuencia1();
}

void conf_sw_btn(void)
{
  pinMode(SW, INPUT);
  pinMode(BTN, INPUT);
  attachInterrupt(digitalPinToInterrupt(SW), isr_start_stop, FALLING);
  attachInterrupt(digitalPinToInterrupt(BTN), isr_clear, FALLING);
}

void conf_timer(void)
{
  Timer0_Cfg = timerBegin(0, 250, true); // Timer de hardware 0, dividiendo la frecuencia base de 80MHz por 80 (1000kHz o 1MHz)
  timerAttachInterrupt(Timer0_Cfg, &Timer0_ISR, true);
  timerAlarmWrite(Timer0_Cfg, 4000, true); // Interrupción cada 1000 microsegundos (1ms)
  timerAlarmEnable(Timer0_Cfg);
}

void secuencia1()
{
  unsigned long tactual = millis();
  if (tactual - tinicio >= periodo)
  {
    tinicio = tactual;

    // Apaga el LED en la posición anterior a currentLed
    int anteriorLed = (currentLed == 0) ? leds - 1 : currentLed - 1;
    digitalWrite(pinesLeds[anteriorLed], LOW);

    // Enciende el LED en la posición currentLed
    digitalWrite(pinesLeds[currentLed], HIGH);

    // Actualiza el valor de currentLed para el siguiente ciclo
    currentLed = (currentLed + 1) % leds;
  }
}

